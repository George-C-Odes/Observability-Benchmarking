quarkus:
  analytics:
    disabled: true
  application:
    ui-header: "Quarkus"
  http:
    accept-backlog: 10000
    http2: false
    idle-timeout: 60s
    # Keep io-threads/event-loops aligned with CPU limits (often set via -XX:ActiveProcessorCount in JAVA_TOOL_OPTIONS).
    io-threads: 8
    limits:
      max-connections: 10000
      max-concurrent-streams: 1024
    port: 8080
    read-timeout: 1s
  log:
    category:
      io.github.georgecodes.benchmarking.quarkus:
        level: INFO
    console:
      format: "%d{yyyy-MM-dd HH:mm:ss} %-5p [%c{2.}] (%t) %s%e%n"
      enabled: true
    level: INFO
  micrometer:
    binder:
      enable-all: false
      grpc-client:
        enabled: false
      grpc-server:
        enabled: false
      http-client:
        enabled: false
      http-server:
        enabled: false
      jvm: false
      netty:
        enabled: true
      system: true
      vertx:
        enabled: true
      virtual-threads:
        enabled: true
    enabled: true
    export:
      json:
        enabled: true
        path: metrics/json
      prometheus:
        enabled: false
        path: metrics/prometheus
  native:
    container-build: false
    debug:
      enabled: true
    enabled: false
    monitoring:
      - HEAPDUMP
      - JFR
    native-image-xmx: 10g
  otel:
    sdk:
      disabled: true  #Run time
    enabled: true     #Build time
    metrics:
      enabled: true
    traces:
      enabled: true
    logs:
      enabled: true
    security-events:
      enabled: false
  smallrye-health:
    ui:
      enabled: false
  # platform endpoint uses blocking threads; max-threads should scale with expected concurrent blocking requests.
  # For pure throughput/CPU-bound scenarios, keeping it closer to CPU count reduces context switching.
  thread-pool:
    max-threads: 32
  vertx:
    event-loops-pool-size: 8
  virtual-threads:
    enabled: true
    name-prefix: "vthread-"